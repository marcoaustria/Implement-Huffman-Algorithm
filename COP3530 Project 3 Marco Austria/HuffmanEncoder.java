import java.io.BufferedReader;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.util.PriorityQueue;
import java.util.Scanner;
import java.util.TreeMap;

public class HuffmanEncoder implements HuffmanCoding {

	// -----------------------------------------------------------------------------getFrequencies()
	// take a file as input and create a table with characters and frequencies
	// print the characters and frequencies
	public String getFrequencies(File inputFile) throws FileNotFoundException {

		// read file
		BufferedReader br = new BufferedReader(new FileReader(inputFile));

		TreeMap<Character, Integer> map = new TreeMap<Character, Integer>();

		try {

			int character;

			// read each character in .txt file
			while ((character = br.read()) != -1)

				// update if already held
				if (map.containsKey((char) character)) {
					map.replace((char) character, map.get((char) character) + 1);

				}

				// add to map as new
				else
					map.put((char) character, 1);

		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}

		finally {
			try {
				br.close();
			} catch (IOException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
		}

		// print characters and frequencies
		String charFreqTable = new String();

		for (char element : map.keySet()) {

			// one line of the table would be as follows:
			charFreqTable += element + " " + map.get(element) + "\n";
		}
		return charFreqTable;

	}

	// -----------------------------------------------------------------------------buildTree()
	// take a file as input and create a Huffman Tree
	public HuffTree buildTree(File inputFile) throws FileNotFoundException, Exception {

		String frequencies = getFrequencies(inputFile);
		Scanner scan = new Scanner(frequencies);

		PriorityQueue<HuffTree> pq = new PriorityQueue<HuffTree>();

		// add every frequency to priority queue
		while (scan.hasNext()) {
			String characterString = scan.next();
			pq.add(new HuffTree(characterString.charAt(0), Integer.valueOf(scan.next())));

		}

		HuffTree tmpLeft, tmpRight, tmpParent = null;

		// combine trees to make 1 Huffman Tree
		while (pq.size() > 1) { // While two items left
			tmpLeft = pq.poll();
			tmpRight = pq.poll();
			tmpParent = new HuffTree(tmpLeft.root(), tmpRight.root(), tmpLeft.weight() + tmpRight.weight());
			pq.add(tmpParent); // Return new tree to heap
		}

		scan.close();

		return pq.poll();
	}

	// -----------------------------------------------------------------------------encodeFile()
	// take a file and a HuffTree and encode the file.
	// output a string of 1's and 0's representing the file
	public String encodeFile(File inputFile, HuffTree huffTree) throws FileNotFoundException {

		String fileCoded = "";

		BufferedReader br = new BufferedReader(new FileReader(inputFile));

		try {

			int character;

			// read each character in txt file
			while ((character = br.read()) != -1) {

				String s = findCode(huffTree.root(), "", (char) character);

				// get rid of "!!"
				s = s.substring(0, s.indexOf('!'));

				// add code to string
				fileCoded += s;

			}

		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}

		finally {
			try {
				br.close();
			} catch (IOException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
		}

		return fileCoded;

	}

	// -----------------------------------------------------------------------------decodeFile()
	// take a String and HuffTree and output the decoded words
	public String decodeFile(String code, HuffTree huffTree) throws Exception {

		String decodedWords = "";

		HuffBaseNode iterRoot = huffTree.root();

		// use every digit to traverse huffman tree and find character
		for (char c : code.toCharArray()) {

			// if not a leaf
			if (!iterRoot.isLeaf()) {
				if (c == '0') {

					iterRoot = ((HuffInternalNode) iterRoot).left();

				} else if (c == '1') {
					iterRoot = ((HuffInternalNode) iterRoot).right();

				}
			} // if

			// if is a leaf, reset to hufftree
			if (iterRoot.isLeaf()) {
				decodedWords += ((HuffLeafNode) iterRoot).value();
				iterRoot = huffTree.root();
			}

		} // for

		return decodedWords;
	}

	// -----------------------------------------------------------------------------findCode()
	// note: will return with !! at the end, delete after
	// find code given a character
	public static String findCode(HuffBaseNode root, String s, char c) {

		// base case; if the left and right are null
		// then its a leaf node and we print
		// the code s generated by traversing the tree.
		if (root.isLeaf()) {
			if (c == ((HuffLeafNode) root).value()) {
				// found char
				return s + "!!";
			} else
				return "";
		}

		// if we go to left then add "0" to the code.
		// if we go to the right add"1" to the code.

		// recursive calls for left and
		// right sub-tree of the generated tree.

		String left = findCode(((HuffInternalNode) root).left(), s + "0", c);
		String right = findCode(((HuffInternalNode) root).right(), s + "1", c);

		// found it
		if (left.contains("!!")) {
			return left;
		} else if (right.contains("!!")) {
			return right;
		} else
			return "NOT FOUND";
	}

	// -----------------------------------------------------------------------------recursiveHuffTree()
	public static TreeMap<Character, String> recursiveHuffTree(HuffBaseNode root, String s,
			TreeMap<Character, String> map) {

		// base case; if leaf we have found the character, add to map
		if (root.isLeaf()) {

			map.put(((HuffLeafNode) root).value(), s);

			// stop searching
			return map;
		}

		// if we go to left then add "0" to the code.
		// if we go to the right add"1" to the code.

		// recursive calls for left and
		// right sub-tree of the generated tree.
		TreeMap<Character, String> temp1 = recursiveHuffTree(((HuffInternalNode) root).left(), s + "0", map);
		TreeMap<Character, String> temp2 = recursiveHuffTree(((HuffInternalNode) root).right(), s + "1", map);

		// combine maps
		temp2.putAll(temp1);

		return temp2;

	}

	// -----------------------------------------------------------------------------traverseHuffmanTree()
	// print the characters and their codes
	public String traverseHuffmanTree(HuffTree huffTree) throws Exception {

		// print characters codes
		String charCodeTable = new String();

		TreeMap<Character, String> map = recursiveHuffTree(huffTree.root(), "", new TreeMap<Character, String>());

		for (char element : map.keySet()) {

			// one line of the table would be as follows:
			charCodeTable += element + " " + map.get(element) + "\n";
		}

		return charCodeTable;
	}
}
